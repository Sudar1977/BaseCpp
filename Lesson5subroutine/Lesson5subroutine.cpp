// Lesson5subroutine.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//
#include <iostream>
#include "Header.h"
using namespace std;
//=================================================================================================
int sum(const int a,const int b)
{
    return a + b;
}
//=================================================================================================
void print_num(const int num)
{
    cout << "You number = " << num << endl;
}
//=================================================================================================
void PrintHello()
{
    cout << "Hello World:" << endl;
    return;
}
//=================================================================================================
//Функция — печать массива
//В С++ можно передать аргументы в функцию 3 - я способами :
//● По значению(передается копия переменных).
//● По ссылке(передается адрес переменных).
//● По указателю(передается адрес переменных).
//Передача по значению(переменная size), массивы передаются словно по указателю(int* arr) :

bool PrintArray(const int *arr, int size) // Функция для печати произвольного массива
{
    for (size_t i = 0; i < size; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;
    return true;
}
//=================================================================================================
//По значению, по ссылке, по указателю
int & TryToChange(int a,int* pB,int& rC)
{
    a = 1000;
    *pB = 2000;
    rC = 3000;
    static int r = 100;
    return r;
}
//=================================================================================================
struct MyArr
{
    int arr[3];
};
//=================================================================================================
void foo(MyArr arr)
{
    arr.arr[0] = 0;
}
//=================================================================================================
void foo1(int arr[3])
{
    arr[0] = 0;
}
//=================================================================================================
//Функция инициализации массива
bool InitArray(int* arr, int size) // Получаем указатель на массив и его размер
{
    for (size_t i = 0; i < size; i++)
    {
        arr[i] = rand() % 100; // Случайное число от 0 до 99
    }
    return true;
}
//=================================================================================================
//Инициализация структуры по ссылке
struct TPerson 
{
    string name;
    int id;
};
void InitStruct(TPerson& refVar)
{
    refVar.id = 1053872627;
    refVar.name = "Ivan Petrov";
}
//=================================================================================================
// Инициализация структуры по указателю
void InitStruct(TPerson* pVar)
{
    pVar->id = 1053872628;
    pVar->name = "Ivan Petroff";
}
//=================================================================================================
//Возврат структуры по значению
struct Employee { // Новый тип данных Сотрудник
    long id; // ID сотрудника
    unsigned short age; // его возраст
    double salary; // его зарплата
};
Employee GetStruct(long id, unsigned short age, double salary)
{
    Employee em;
    em.id = id;
    em.age = age;
    em.salary = salary;
    return em; // Возвращаем по значению
}

//=================================================================================================
// Соглашение о вызове (англ. calling convention) — описание технических особенностей вызова 
//подпрограмм, определяющее:
// Соглашение о вызове описывает следующее:
//● способ передачи аргументов в функцию(регистры, стек).
//● порядок размещения аргументов в регистрах и / или стеке.
//● код, ответственный за очистку стека(вызывающая функция, вызываемая функция).
//● конкретные инструкции, используемые для вызова и возврата.
//● способ передачи в функцию указателя на текущий объект(this или self) в объектноориентированных языках(через регистры или стек).
//● код, ответственный за сохранение и восстановление содержимого регистров до и после вызова
//функции(вызывающая функция, вызываемая функция).
//● список регистров, подлежащих сохранению / восстановлению до / после вызова функции.
//Соглашения о вызовах, используемые на x86 при 32 - битной адресации :
//cdecl, pascal, stdcall или winapi, fastcall, safecall, thiscall
//fastcall - общее название соглашений, передающих параметры через регистры(обычно это самый
//    быстрый способ, отсюда название).Если для сохранения всех параметров и промежуточных результатов
//    регистров не достаточно, используется стек.
//=================================================================================================
// Ключевые слова: __fastcall и inline
// inline — рекомендация компилятору встроить код функции в место ее вызова. Повышается скорость работы 
//программы, но увеличивается ее размер.
//__fastcll — рекомендуем компилятору передавать аргументы функции через регистры CPU.
//Пример:
inline int Add(int a, int b) // Функция суммирования с inline
{
    return a + b;
}
void __fastcall PrintAB(int a, int b) // Передаем аргументы функции через регистры CPU
{
    cout << "a=" << a << " b=" << b << endl;
}
//=================================================================================================
//Переменное число параметров функции
//Язык программирования С допускает использование функций, которые имеют нефиксированное количество
//параметров.Более того может быть неизвестным не только количество, но и типы параметров.То есть
//точное определение параметров становится известным только во время вызова функции.Для определения
//параметров неопределенной длины в таких функциях используется многоточие.При этом надо учитывать,
//что функция должна иметь как минимум один обязательный параметр.
//Функция, которая вычисляет сумму чисел, количество чисел нефиксировано :
int sum(int n, ...)
{
    int result = 0;
    // получаем указатель на параметр n
    for (int* ptr = &n; n > 0; n--)
    {
        ptr = ptr + 1;
        result += *ptr;
    }
    return result;
}
//=================================================================================================
//Перегрузка функций
// Перегрузка функций — это возможность определять несколько функций с одним и тем же 
//именем, но с разными параметрами.Это возможно благодаря тому что компилятор делает :
//name mangling(изменение имени, декорация имени).
float sum(float a, float b)
{
    return a + b;
}
string sum(string a, string b)
{
    return a + b;
}
string sum(string a, string b, string c)
{
    return a + b + c;
}
//=================================================================================================
// Указатели на функцию
// Можно использовать объектную обертку std::function (since C++11) способ 1, или объявлять сырые 
//указатели на функцию(способ 2).Если указатель на функцию передается в другую функцию как параметр
//то это называется функцией обратного вызова(callback function)
#include <functional> // Для std::function
//int Add(int a, int b)
//{
//    return a + b;
//}
int Subtract(int a, int b)
{
    return a - b;
}
//=================================================================================================
// Callback functions
typedef double (*MyFunPtr)(double, double); // Создаем тип данных MyFunPtr
double AddDouble(double a, double b) // Функция сложения
{
    return a + b;
}
double Subtract(double a, double b) // Функция вычитания
{
    return a - b;
}
double PerformCalculation(MyFunPtr PtrF) // Сложные вычисления, параметр callback функция
{
    const double pi = 3.1415926535, g = 9.80665;

    double ret = PtrF(pi, g) + pi * g * 2 - g * g; // сложная формула

    return ret;
}
//=================================================================================================
//Конфликт имен возникает, когда два одинаковых идентификатора находятся в одной области видимости, и 
//компилятор не может понять, какой из этих двух следует использовать в конкретной ситуации.Компилятор
//    или линкер выдаст ошибку, так как у них недостаточно информации, чтобы решить эту неоднозначность.
//    Как только программы увеличиваются в объемах, количество идентификаторов также увеличивается,
//    следовательно, увеличивается и вероятность возникновения конфликтов имен.
namespace MyStd // Объявляем наше пространство имен
{
    int foo = 100;
    void bar(float f)
    {
        std::cout << "Some useful function: " << f;
    }
}
namespace //Бывают также безымянные пространства имен.
{
}
//=================================================================================================
// Рекурсия
// Рекурсия — кода функция вызывает саму себя. Чтоб не получилась бесконечная рекурсия и переполнение 
//стека нужно предусмотреть остановку рекурсии.
//Некоторые сложные алгоритмы упрощаются если использовать рекурсию.
long long factorial(long long f) // рекурсивная функция для нахождения n!
{
    if (f == 1 || f == 0) // базовое или частное решение
    {
        return 1; // все мы знаем, что 1!=1 и 0!=1
    }
    // функция вызывает саму себя, причём её аргумент уже на 1 меньше
    long long result = f * factorial(f - 1);
    return result;
}
//=================================================================================================
//Аргументы функции по умолчанию
void PrintNumber(int num, char separator = '=')
{
    cout << "num" << separator << num << endl;
}
//=================================================================================================
// Класс памяти static
// У нас в программе 2 модуля:
//Main.cpp
// 
static int test = 101; // 1. Обходим правило ORD

void fun()
{
    static int bar = 10; // 2. Переменная не уничтожается после выхода из fun
    bar++;
    std::cout << "bar=" << bar << std::endl;
}

//=================================================================================================
//=================================================================================================
int main()
{
    {
        int c = sum(10, 20);
        print_num(c);
    }
    {
        PrintHello();
        PrintHello();
    }
    {
        const int mysize = 5;
        int myarr[] = { 10, 20, 30, 20, 10 };
        if (PrintArray(myarr, mysize)) // Вызываем нашу функцию
        {
            cout << "Array was successfuly printed" << endl;
        }
    }
    {
        int v1 = 100;
        int v2 = 200;
        int v3 = 300;
        TryToChange(v1, &v2, v3);
        print_num(v1);
        print_num(v2);
        print_num(v3);
    }
    {
        MyArr arr = { 1,2,3 };
        foo(arr);
        PrintArray(arr.arr, 3);
        foo1(arr.arr);
        PrintArray(arr.arr, 3);
    }
    {
        const int mysize = 5;
        int myarr[mysize];
        if (InitArray(myarr, mysize))
        {
            cout << "Array was successfuly initialized" << endl;
            PrintArray(myarr, mysize);
        }
    }
    {
        TPerson p1;
        InitStruct(p1); // Передаем структуру в функцию по ссылке для инициализации
        cout << "id = " << p1.id << " name = " << p1.name << endl;
        InitStruct(&p1); // Передаем адрес структуры в функцию для инициализации
        cout << "id = " << p1.id << " name = " << p1.name << endl;

    }
    {
        Employee eee = GetStruct(543452465, 33, 120'000.0);
        // печатаем полученную структуру
        cout << "id = " << eee.id << " age = " << eee.age << " salary = "  << eee.salary << endl;
    }
    {
        // это работает, так как мы предварительно (выше функции main()) объявили функцию add()
        std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
    }
    {
        int c = Add(100, 200);
        PrintAB(c, 2 * c); // Вывод на эран: a=300 b=600
    }
    {
        cout << "sum = " << sum(4, 1, 2, 3, 4) << endl;
        cout << "sum = " << sum(5, 12, 21, 13, 4, 5) << endl;
    }
    {
        cout << "sum=" << sum(4, 1) << " sum=" << sum(4.1f, 1.4f) << endl;
        cout << "sum=" << sum("aaa", "bbb") << " sum=" << sum("123", "ASD", "poi") << endl;
    }
    {
        function<int(int, int)> fun = Add; // Способ 1. Настраиваем "обертку" fun на функцию Add
        cout << fun(100, 200) << endl;
        int (*funPtr)(int, int) = Subtract; // Способ 2. Настраиваем указатель на функцию Subtract
        cout << funPtr(100, 200) << endl;
    }
    {
        cout << PerformCalculation(AddDouble) << endl;
        cout << PerformCalculation(Subtract) << endl;
    }
    { 
        
        //Можно погулить или почитать тут : https://it.wikireading.ru/35901

        MyStd::foo = 1000;
        MyStd::bar(8.888);
    }
    {
        unsigned long n;
        cout << endl << "Enter n!: ";
        n = 10;
        //cin >> n;
        cout << n << "!" << " = " << factorial(n) << endl;
    }
    {
        PrintNumber(1000); // Срабатывает параметр по умолчанию
        // Задаем другое значение для параметра по умолчанию
        PrintNumber(2000, ':');
        PrintNumber(2000, ' ');
        cout << endl;
    }
    {
        fun();
        fun();
        fun();
        cout << "static test=" << test << endl;
    }
//Russian: https://ru.cppreference.com/w/
    return 0;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.

