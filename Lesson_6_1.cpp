// Lesson_6_1.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
#include <malloc.h>
#include <new.h>
#include <fstream> // Для использования ofstream

using namespace std;

//======================================================================================
//Работа с кучей - С-style
//======================================================================================
//Прототипы функций:
//void* malloc(size_t sizeMem); // Размер массива в байтах
//void* calloc(size_t number, size_t size); // Число элементов, размер элемента в байтах
//void* realloc(void* ptrMem, size_t size); // Выделяет новый блок памяти, копирует, освобождает старый указатель.
//void free(void* ptrMem);
//Пример программы:
int main_malloc(size_t n)
{
    int* a; // Указатель на динамически выделенный массив
    //int n;
    cout << "Entered size of your array: " << n << endl;
    //cin >> n;
    cout << "Size of array in bytes: " << n * sizeof(int) << endl;
    a = (int*)malloc(n * sizeof(int)); // Выделение памяти
    a[0] = 100; // Работа с массивом
    free(a); // Освобождаем память
    a = NULL;
    return 0;
}
//======================================================================================
//Операторы new и delete в С++
//======================================================================================
//Безопасная работа с new (используем std::nothrow):
//int n; // Количество элементов
int main_new_nothrow(int n)
{
    int* ptrArr; // Указатель на массив
    //int n; // Количество элементов
    cout << "Entered size of your array: " << n << endl;
    if (n > 0)
    {
        ptrArr = new (std::nothrow) int[n]; // Выделение памяти под одномерный массив
        if (ptrArr != nullptr) // Если память не выделена то указатель будет нулевой
        {
            // Работа с массивом
            ptrArr[0] = 100;
            std::cout << "ptrArr[0] = " << ptrArr[0] << endl;
            // освобождение памяти
            delete[] ptrArr;
            ptrArr = nullptr;
        }
        else
        {
            cerr << "Error! Can not allocate memory!" << endl;
        }
    }
    return 0;
}
//======================================================================================
//Операторы new и delete в С++
//======================================================================================
//Можно проще, но программа упадет если память не может быть выделена:
//int n; // Количество элементов
int main_new(int n)
{
    int* ptrArr; // Указатель на массив
    std::cout << "Enter size of your array: ";
    //std::cin >> n;

    if (n > 0)
    {
        ptrArr = new int[n]; // Выделение памяти под одномерный массив
        // Работа с массивом
        ptrArr[0] = 100;
        std::cout << "ptrArr[0] = " << ptrArr[0] << endl;
        // освобождение памяти
        delete[] ptrArr;
        ptrArr = nullptr;
    }
    return 0;
}
//======================================================================================
//Выделение динамической памяти для двухмерного массива
//======================================================================================
// Количество элементов m x n
int main_new_matrix(const size_t m, const size_t n)
{
    int** ptrArr; // Указатель на одномерный массив указателей на int
     //= 5;  
     //= 5;

    // 1. Выделение памяти
    ptrArr = new int* [m]; // Выделение памяти под одномерный массив указателей
    for (size_t i = 0; i < m; i++) 
    {
        ptrArr[i] = new int[n]; // Выделяем массив под одномерный int массив
    }
    // 2. Работа с массивом
    ptrArr[0][0] = 100; // Запись в первый элемента матрицы
    ptrArr[m - 1][n - 1] = 200; // Запись в последний элемент матрицы
    cout << "ptrArr[0][0]=" << ptrArr[0][0] << " ptrArr[m-1][n-1]=" << ptrArr[m - 1][n - 1] << endl;
    // 3. Освобождение памяти
    for (size_t i = 0; i < m; i++) 
    {
        delete[] ptrArr[i]; // Освобождаем i-тый одномерный int массив
    }
    delete[] ptrArr; // Удаляем массив указателей
    ptrArr = nullptr;
    return 0;
}
//======================================================================================
//Создаем динамически структуру
//======================================================================================
// Новый тип данных Сотрудник
struct Employee 
{ 
    long id; // ID сотрудника
    unsigned short age; // его возраст
    double salary; // его зарплата
};
// перечисление — размер компании
enum CompanySize { CS_SMALL, CS_MIDDLE, CS_BIG }; 
// Новый тип данных Компания
struct Company 
{ 
    Employee people[30]; // Ее сотрудники (30 максимум)
    Employee director; // Директор
    CompanySize size; // Размер компании
    unsigned int PeopleNumber; // количество сотрудников
};
int main_new_struct() 
{
    // 1. Выделение памяти для структуры
    Company* pCompany = new Company;
    // 2. Работаем со структурой
    pCompany->director = { 125093, 45, 350'000.0 };
    pCompany->size = CS_MIDDLE;
    pCompany->PeopleNumber = 215;
    pCompany->people[0] = pCompany->director;
    pCompany->people[1] = { 134578, 34, 60'000.0 };
    // 3. Освобождаем память
    delete pCompany;
    return 0;
}
//======================================================================================
//Создаем динамически массив структур
//======================================================================================
int main_new_struct_array() 
{
    // 1. Выделение памяти для массива структур
    const size_t size = 3;
    Employee* pArray = new (std::nothrow) Employee[size];
    if (pArray != nullptr)
    {
        // 2. Работаем с массивом структур
        pArray[0].age = 30;
        pArray[0].id = 55645435467;
        pArray[0].salary = 35'000.0;
        pArray[1] = { 78687678, 35, 40'000.0 };
        pArray[2] = { 97655667, 50, 80'000.0 };
        // 3. Освобождаем память
        delete[] pArray;
        pArray = nullptr;
    }
    return 0;
}
//======================================================================================
//Запись в файл - ofstream
//======================================================================================
int main_ofstream(const char* filename)
{
    const size_t size = 6;
    int array[size] = { 10, 20, 70, -90, 50, 80 };
    //ofstream fout("data.txt"); // 1. Создаем файл для записи данных
    ofstream fout(filename); // 1. Создаем файл для записи данных
    // 2. Сохраняем в файл элементы массива
    int i = 0;
    for (int element : array) // Цикл по массиву array
    {
        fout << "elem[" << i++ << "]=" << element << endl;
    }
    fout.close(); // Закрываем файл
    return 0;
}
//О ofstream подробнее :
//https://en.cppreference.com/w/cpp/io/basic_ofstream
//======================================================================================
//Чтение из файла - ifstream
//======================================================================================
int main_ifstream(const char* filename)
{
    const size_t size = 6;
    int array[size] = { 0 };
    ifstream fin(filename); // 1. Открываем файл для чтения данных
    if (fin.is_open()) // Если файл был успешно открыт
    {
        cout << "File opened " << filename << endl; // Сообщение об открытии файла
        // 2. Читаем числа из файла в массив
        for (int i = 0; i < size; i++)
        {
            fin >> array[i]; // Читаем из файла элемент массива
            cout << array[i] << " "; // Выводим на экран
        }
        cout << endl;
        fin.close(); // Закрываем файл
    }
    else
    {
        cout << "Error. Can not open file."; // Сообщение об ошибке
    }
    //cin.get(); // Ждем нажатия клавиши для задержки закрытия программы
    return 0;

}
//======================================================================================
//Читаем строку из ifstream, функция getline
//======================================================================================
int main_getline(const char* filename)
{
    ifstream fin(filename); // 1. Открываем файл для чтения данных
    if (fin.is_open()) // Если файл был успешно открыт
    {
        // 2. Выведем содержимое файла на экран
        const size_t size = 255;
        char buf[size];
        while (!fin.eof()) // Пока не конец файла
        {
            fin.getline(buf, size); // Читаем из файла строку
            cout << buf << endl; // Выводим на экран
        }
        fin.close(); // Закрываем файл
    }
    else
    {
        cout << "Error. Can not open file."; // Сообщение об ошибке
    }
    //cin.get(); // Ждем нажатия клавиши для задержки закрытия программы
    return 0;
}


//======================================================================================
//Запись и чтение в бинарные файлы функции write и read
//======================================================================================
// Структура сотрудник
struct TEmploee 
{ 
    int id;
    double salary;
    unsigned short age;
    char name[32];
};

int main_write_read(const string FileName)
{
    TEmploee e1 = { 12354321, 120'000.0, 32, "David Saimon" };
    // Запись структуры в бинарный файл с помощью функции write
    ofstream fout(FileName, ios_base::binary);
    if (fout.is_open())
    {
        fout.write((char*)&e1, sizeof(e1));
        fout.close();
    }
    TEmploee e2 = { 0 }; // Структура для считывания из файла
    // Чтение структуры из бинарного файла с помощью функции read
    ifstream fin(FileName, ios_base::binary);
    if (fin.is_open())
    {
        fin.read((char*)&e2, sizeof(e2));
        fin.close();
    }
    cout << e2.id << " " << e2.salary << " " << e2.age << " " << e2.name << endl;
    return 0;
}
//======================================================================================
//Считываем безопасно число из std::cin, функции fail, clear и ignore
//======================================================================================
int getIntNumber()
{
    while (true) // цикл продолжается до тех пор, пока пользователь не введёт корректное значение
    {
        cout << "Enter an integer value: ";
        int num;
        cin >> num;
        if (cin.fail()) // если предыдущее извлечение оказалось неудачным,
        {
            cout << "Error. Please enter an integer number!" << endl;
            cin.clear(); // то возвращаем cin в 'обычный' режим работы
            cin.ignore(32767, '\n'); // и удаляем значения предыдущего ввода из входного буфера
        }
        else // если всё хорошо, то возвращаем num
        {
            return num;
        }
    }
}
//======================================================================================
//С++17 — библиотека filesystem
//======================================================================================
//В ней много полезных функций для работы с файловой системой, директориями и файлами.Можно
//например получить список все файлов в любой папке.
//Подробнее состав библиотеки : https://en.cppreference.com/w/cpp/filesystem
#include <iostream>
#include <filesystem>

namespace fs = std::filesystem; // Упрощаем namespace

using namespace std;

int main_file_remove(const string filename)
{
    //const char filename[] = "mydata.txt";
    if (fs::exists(filename)) // Если файл существует
    {
        fs::remove(filename); // Удаляем его
        cout << filename << " - was removed!" << endl;
    }
    return 0;
}
//Чтобы использовать эту библиотеку необходимо в свойствах проекта, в опциях компилятора в VS включить
//C++17 или выше.

//======================================================================================
//main
//======================================================================================
int main()
{
    int a=100, b, c;
    int* ptr = nullptr;//C++ 11
    int* ptr2 =  &a;
    *ptr2 = 200;
    int* p1 = NULL;

    const size_t SIZE_MALLOC = 100;

    main_malloc(SIZE_MALLOC);
    main_new(200);
    main_new_nothrow(10000000000);
    main_new_matrix(5, 5);
    main_new_struct();
    main_new_struct_array();
    main_ofstream("data.txt");
    main_ifstream("mydata.txt");
    main_getline("mydata.txt");
    main_write_read("1.bin");
    main_ofstream("data1.txt");
    main_file_remove("data1.txt");
    cout << "Your int number: " << getIntNumber() << endl;
    cout << "Hello World!\n";
    
    //Вопросы на собеседованиях по С++   //    (информация для продвинутых)
    //    1. Можно ли перегрузить операции new и delete ?
    //    2. Что такое new placement ?
    char buf[1000];
    int* p2 = new (buf) int[100];
    if (p2 != nullptr)
    {
        //delete[] p2;
    }
    else
    {
        cerr << "Error";
    }

 /*   Борьба с memory leaks
    (информация для продвинутых)
        Умный указатель(англ.smart pointer) — идиома косвенного обращения к памяти, которая широко
        используется при программировании на языках высокого уровня : C++, Rust и так далее.Как правило,
        реализуется в виде специализированного класса(обычно — параметризованного), имитирующего
        интерфейс обычного указателя и добавляющего необходимую новую функциональность(например —
            проверку границ при доступе или очистку памяти).
        Как правило, основной целью задействования умных указателей является инкапсуляция работы с
        динамической памятью таким образом, чтобы свойства и поведение умных указателей имитировали
        свойства и поведение обычных указателей.При этом на них возлагается обязанность своевременного и
        аккуратного высвобождения выделенных ресурсов, что упрощает разработку кода и процесс отладки,
        исключая утечки памяти и возникновение висячих ссылок.
        В С++11 появилось 3 - и вида умных указателей :
    ● std::unique_ptr
        ● std::shared_ptr
        ● std::weak_ptr
        Парадигма программирования RAII : Одна из лучших особенностей классов — это деструкторы, которые
        автоматически выполняются при выходе объекта класса из области видимости.При выделении памяти в
        конструкторе класса, вы можете быть уверены, что эта память будет освобождена в деструкторе при
        уничтожении объекта класса(независимо от того, выйдет ли он из области видимости, будет ли явно
            удален и т.д.).Это лежит в основе парадигмы программирования 
            RAII(Resource Acquisition Is Initialization).*/


    return 0;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
